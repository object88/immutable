package immutable

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"hash/fnv"
	"math"
)

type bucket struct {
	entryCount byte
	hobs       []uint32
	entries    []entry
	overflow   *bucket
}

type entry struct {
	key   uint32
	value Value
}

// HashMap is a read-only key-to-value collection
type HashMap struct {
	count   uint32
	size    uint32
	buckets []*bucket
}

const (
	lobSize        = 3
	bucketCapacity = 1 << lobSize
	loadFactor     = 6.0
)

// NewHashMap creates a new instance of a HashMap
func NewHashMap(contents map[uint32]Value) *HashMap {
	initialCount := uint32(len(contents))
	initialSize := nextPowerOfTwo(uint32(math.Ceil(float64(initialCount) / loadFactor)))
	buckets := make([]*bucket, initialSize)

	for i := 0; i < int(initialSize); i++ {
		buckets[i] = &bucket{
			entryCount: 0,
			hobs:       make([]uint32, bucketCapacity),
			entries:    make([]entry, bucketCapacity),
			overflow:   nil,
		}
	}

	for k, v := range contents {
		hashkey := calculateHash(k)
		scaledHashkey := hashkey % initialSize
		selectedBucket := scaledHashkey & bucketCapacity
		bucket := buckets[selectedBucket]
		bucket.entries[bucket.entryCount] = entry{k, v}
		bucket.hobs[bucket.entryCount] = scaledHashkey >> lobSize
		bucket.entryCount++
	}

	hash := &HashMap{initialCount, initialSize, buckets}
	return hash
}

func (h *HashMap) String() string {
	var buffer bytes.Buffer
	buffer.WriteString(fmt.Sprintf("Count: %d\n", h.count))
	buffer.WriteString(fmt.Sprintf("Size: %d\n", h.size))
	buffer.WriteString(fmt.Sprintf("{\n"))
	for _, v := range h.buckets {
		buffer.WriteString("\t[\n")
		buffer.WriteString(fmt.Sprintf("\tentryCount: %d\n", v.entryCount))
		for i := 0; i < int(v.entryCount); i++ {
			buffer.WriteString(fmt.Sprintf("\t\t[%d,%d] -> %s\n", v.hobs[i], v.entries[i].key, v.entries[i].value))
		}
		buffer.WriteString("\t]\n")
	}
	buffer.WriteString(fmt.Sprintf("}\n"))
	return buffer.String()
}

// Get returns the value for the given key
func (h *HashMap) Get(key uint32) Value {
	hashkey := calculateHash(key)
	scaledHashkey := hashkey % h.size
	selectedBucket := scaledHashkey & bucketCapacity
	b := h.buckets[selectedBucket]
	offset := 0
	for ; offset < bucketCapacity && b.hobs[offset] != scaledHashkey>>3; offset++ {
	}
	if offset == bucketCapacity {
		return nil
	}
	return b.entries[offset].value
}

func calculateHash(value uint32) uint32 {
	hasher := fnv.New32a()

	binary.Write(hasher, binary.LittleEndian, value)
	hash := hasher.Sum32()
	return hash
}

// http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
func nextPowerOfTwo(size uint32) uint32 {
	size--
	size |= size >> 1
	size |= size >> 2
	size |= size >> 4
	size |= size >> 8
	size |= size >> 16
	size++
	return size
}
